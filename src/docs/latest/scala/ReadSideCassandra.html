<h1 id="Cassandra-Read-Side-support"><a class="section-marker" href="#Cassandra-Read-Side-support">§</a>Cassandra Read-Side support</h1>
<p>This page is specifically about Lagom&rsquo;s support for Cassandra read-sides. Before reading this, you should familiarize yourself with Lagom&rsquo;s general <a href="ReadSide.html">read-side support</a>.</p><h2 id="Query-the-Read-Side-Database"><a class="section-marker" href="#Query-the-Read-Side-Database">§</a>Query the Read-Side Database</h2>
<p>Let us first look at how a service implementation can retrieve data from Cassandra.</p>
<pre class="prettyprint"><code class="language-scala">import scala.concurrent.Future
import akka.NotUsed
import akka.stream.scaladsl.Source
import com.lightbend.lagom.scaladsl.api.Service
import com.lightbend.lagom.scaladsl.api.ServiceCall
import com.lightbend.lagom.scaladsl.persistence.cassandra.CassandraSession
</code></pre>
<pre class="prettyprint"><code class="language-scala">class BlogServiceImpl(cassandraSession: CassandraSession) extends BlogService {

  override def getPostSummaries() = ServiceCall { request =&gt;
    val response: Source[PostSummary, NotUsed] =
      cassandraSession.select(&quot;SELECT id, title FROM blogsummary&quot;)
        .map(row =&gt; PostSummary(row.getString(&quot;id&quot;), row.getString(&quot;title&quot;)))
    Future.successful(response)
  }
}</code></pre>
<p>Note that the <a href="api/index.html#com/lightbend/lagom/scaladsl/persistence/cassandra/CassandraSession">CassandraSession</a> is injected in the constructor. <code>CassandraSession</code> provides several methods in different flavors for executing queries. The one used in the above example returns a <code>Source</code>, i.e. a streamed response. There are also methods for retrieving a list of rows, which can be useful when you know that the result set is small, e.g. when you have included a <code>LIMIT</code> clause.</p>
<p>All methods in <code>CassandraSession</code> are non-blocking and they return a <code>Future</code> or a <code>Source</code>. The statements are expressed in <a href="https://docs.datastax.com/en/cql/3.3/cql/cqlIntro.html">Cassandra Query Language</a> (CQL) syntax. See <a href="http://docs.datastax.com/en/cql/3.3/cql/cql_using/useQueryDataTOC.html">Querying tables</a> for information about CQL queries.</p><h2 id="Update-the-Read-Side"><a class="section-marker" href="#Update-the-Read-Side">§</a>Update the Read-Side</h2>
<p>We need to transform the events generated by the <a href="PersistentEntity.html">Persistent Entities</a> into database tables that can be queried as illustrated in the previous section. For that we will implement a <a href="api/index.html#com/lightbend/lagom/scaladsl/persistence/ReadSideProcessor">ReadSideProcessor</a> with assistance from the <a href="api/index.html#com/lightbend/lagom/scaladsl/persistence/cassandra/CassandraReadSide">CassandraReadSide</a> support component. It will consume events produced by persistent entities and update one or more tables in Cassandra that are optimized for queries.</p>
<p>This is how a <a href="api/index.html#com/lightbend/lagom/scaladsl/persistence/ReadSideProcessor">ReadSideProcessor</a> class looks like before filling in the implementation details:</p>
<pre class="prettyprint"><code class="language-scala">import scala.concurrent.ExecutionContext
import scala.concurrent.Future
import akka.Done
import com.datastax.driver.core.BoundStatement
import com.datastax.driver.core.PreparedStatement
import com.lightbend.lagom.scaladsl.persistence.AggregateEventTag
import com.lightbend.lagom.scaladsl.persistence.EventStreamElement
import com.lightbend.lagom.scaladsl.persistence.ReadSideProcessor
import com.lightbend.lagom.scaladsl.persistence.cassandra.CassandraReadSide
import com.lightbend.lagom.scaladsl.persistence.cassandra.CassandraSession
import scala.concurrent.Promise
</code></pre>
<pre class="prettyprint"><code class="language-scala">class BlogEventProcessor(session: CassandraSession, readSide: CassandraReadSide)(implicit ec: ExecutionContext)
  extends ReadSideProcessor[BlogEvent] {

  override def buildHandler(): ReadSideProcessor.ReadSideHandler[BlogEvent] = {
    // TODO build read side handler
    ???
  }

  override def aggregateTags: Set[AggregateEventTag[BlogEvent]] = {
    // TODO return the tag for the events
    ???
  }
}</code></pre>
<p>You can see that we have injected the Cassandra session and Cassandra read-side support, these will be needed later.</p>
<p>You should already have implemented tagging for your events as described in the <a href="ReadSide.html">Read-Side documentation</a>, so first we&rsquo;ll implement the <code>aggregateTags</code> method in our read-side processor stub, like so:</p>
<pre class="prettyprint"><code class="language-scala">override def aggregateTags: Set[AggregateEventTag[BlogEvent]] =
  BlogEvent.Tag.allTags</code></pre><h3 id="Building-the-read-side-handler"><a class="section-marker" href="#Building-the-read-side-handler">§</a>Building the read-side handler</h3>
<p>The other method on the <code>ReadSideProcessor</code> is <code>buildHandler</code>. This is responsible for creating the <a href="api/index.html#com/lightbend/lagom/scaladsl/persistence/ReadSideProcessor.ReadSideHandler">ReadSideHandler</a> that will handle events. It also gives the opportunity to run two callbacks, one is a global prepare callback, the other is a regular prepare callback.</p>
<p><a href="api/index.html#com/lightbend/lagom/scaladsl/persistence/cassandra/CassandraReadSide">CassandraReadSide</a> has a <code>builder</code> method for creating a builder for these handlers, this builder will create a handler that will automatically handle readside offsets for you. It can be created like so:</p>
<pre class="prettyprint"><code class="language-scala">val builder = readSide.builder[BlogEvent](&quot;blogsummaryoffset&quot;)</code></pre>
<p>The argument passed to this method is the ID of the event processor that Lagom will use when it persists offsets to its offset store. The offset store is a Cassandra table, which will be created for you if it doesn&rsquo;t exist. You can manually create this table yourself if you wish, the DDL for its creation is as follows:</p>
<pre class="prettyprint"><code class="language-sql">CREATE TABLE IF NOT EXISTS offsetStore (
    eventProcessorId text,
    tag text,
    timeUuidOffset timeuuid,
    sequenceOffset bigint,
    PRIMARY KEY (eventProcessorId, tag)
)
</code></pre><h3 id="Global-prepare"><a class="section-marker" href="#Global-prepare">§</a>Global prepare</h3>
<p>The global prepare callback runs at least once across the whole cluster. It is intended for doing things like creating tables and preparing any data that needs to be available before read side processing starts. Read side processors may be sharded across many nodes, and so tasks like creating tables should usually only be done from one node.</p>
<p>The global prepare callback is run from an Akka cluster singleton. It may be run multiple times - every time a new node becomes the new singleton, the callback will be run. Consequently, the task must be idempotent. If it fails, it will be run again using an exponential backoff, and the read side processing of the whole cluster will not start until it has run successfully.</p>
<p>Of course, setting a global prepare callback is completely optional, you may prefer to manage Cassandra tables manually, but it is very convenient for development and test environments to use this callback to create them for you.</p>
<p>Below is an example method that we&rsquo;ve implemented to create tables:</p>
<pre class="prettyprint"><code class="language-scala">private def createTable(): Future[Done] =
  session.executeCreateTable(&quot;CREATE TABLE IF NOT EXISTS blogsummary ( &quot; +
    &quot;id TEXT, title TEXT, PRIMARY KEY (id))&quot;)</code></pre>
<p>It can then be registered as the global prepare callback in the <code>buildHandler</code> method:</p>
<pre class="prettyprint"><code class="language-scala">builder.setGlobalPrepare(createTable)</code></pre><h3 id="Prepare"><a class="section-marker" href="#Prepare">§</a>Prepare</h3>
<p>In addition to the global prepare callback, there is also a prepare callback. This will be executed once per shard, when the read side processor starts up. It can be used for preparing statements in order to optimize Cassandra&rsquo;s handling of them.</p>
<p>Again this callback is optional, here is an example of how to prepare a statement for updating the table:</p>
<pre class="prettyprint"><code class="language-scala">private val writeTitlePromise = Promise[PreparedStatement] // initialized in prepare
private def writeTitle: Future[PreparedStatement] = writeTitlePromise.future

private def prepareWriteTitle(): Future[Done] = {
  val f = session.prepare(&quot;INSERT INTO blogsummary (id, title) VALUES (?, ?)&quot;)
  writeTitlePromise.completeWith(f)
  f.map(_ =&gt; Done)
}</code></pre>
<p>And then to register them:</p>
<pre class="prettyprint"><code class="language-scala">builder.setPrepare(tag =&gt; prepareWriteTitle())</code></pre><h3 id="Registering-your-read-side-processor"><a class="section-marker" href="#Registering-your-read-side-processor">§</a>Registering your read-side processor</h3>
<p>Once you&rsquo;ve created your read-side processor, you need to register it with Lagom. This is done using the <a href="api/index.html#com/lightbend/lagom/scaladsl/persistence/ReadSide"><code>ReadSide</code></a> component:</p>
<pre class="prettyprint"><code class="language-scala">class BlogServiceImpl(
  persistentEntityRegistry: PersistentEntityRegistry,
  readSide: ReadSide,
  myDatabase: MyDatabase) extends BlogService {

  readSide.register[BlogEvent](new BlogEventProcessor(myDatabase))</code></pre><h3 id="Event-handlers"><a class="section-marker" href="#Event-handlers">§</a>Event handlers</h3>
<p>The event handlers take an event, and return a list of bound statements. Rather than executing updates in the handler itself, it is recommended that you return the statements that you want to execute to Lagom. This allows Lagom to batch those statements with the offset table update statement, which Lagom will then executed as a logged batch, which Cassandra executes atomically. By doing this you can ensure exactly once processing of all events, otherwise processing may be at least once.</p>
<p>Here&rsquo;s an example callback for handling the <code>PostAdded</code> event:</p>
<pre class="prettyprint"><code class="language-scala">private def processPostAdded(eventElement: EventStreamElement[PostAdded]): Future[List[BoundStatement]] = {
  writeTitle.map { ps =&gt;
    val bindWriteTitle = ps.bind()
    bindWriteTitle.setString(&quot;id&quot;, eventElement.event.postId)
    bindWriteTitle.setString(&quot;title&quot;, eventElement.event.content.title)
    List(bindWriteTitle)
  }
}</code></pre>
<p>This can then be registered with the builder using <code>setEventHandler</code>:</p>
<pre class="prettyprint"><code class="language-scala">builder.setEventHandler[PostAdded](processPostAdded)</code></pre>
<p>Once you have finished registering all your event handlers, you can invoke the <code>build</code> method and return the built handler:</p>
<pre class="prettyprint"><code class="language-scala">builder.build()</code></pre><h2 id="Underlying-implementation"><a class="section-marker" href="#Underlying-implementation">§</a>Underlying implementation</h2>
<p>The <code>CassandraSession</code> is using the <a href="https://github.com/datastax/java-driver">Datastax Java Driver for Apache Cassandra</a>.</p>
<p>Each <code>ReadSideProcessor</code> instance is executed by an <a href="https://doc.akka.io/docs/akka/2.5/actors.html?language=scala">Actor</a> that is managed by <a href="https://doc.akka.io/docs/akka/2.5/cluster-sharding.html?language=scala">Akka Cluster Sharding</a>. The processor consumes a stream of persistent events delivered by the <code>eventsByTag</code> <a href="https://doc.akka.io/docs/akka/2.5/persistence-query.html?language=scala">Persistence Query</a> implemented by <a href="https://github.com/akka/akka-persistence-cassandra">akka-persistence-cassandra</a>. The tag corresponds to the <code>tag</code> defined by the <code>AggregateEventTag</code>.</p>