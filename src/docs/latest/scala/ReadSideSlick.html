<h1 id="Slick-Read-Side-support"><a class="section-marker" href="#Slick-Read-Side-support">§</a>Slick Read-Side support</h1>
<p>This page is specifically about Lagom&rsquo;s support for relational database read-sides using JDBC. Before reading this, you should familiarize yourself with Lagom&rsquo;s general <a href="ReadSide.html">read-side support</a> and <a href="ReadSideRDBMS.html">relational database read-side support overview</a>.</p><h2 id="Configuration"><a class="section-marker" href="#Configuration">§</a>Configuration</h2>
<p>Slick support builds on top of Lagom&rsquo;s support for <a href="PersistentEntityRDBMS.html">storing persistent entities in a relational database</a>. See that guide for instructions on configuring Lagom to use the correct JDBC driver and database URL.</p>
<p>Next we need to configure the Slick mappings for the read-side model. Note that this example is using the <code>slick.jdbc.H2Profile</code>. Make sure you import your profile of choice instead.</p>
<pre class="prettyprint"><code class="language-scala">import slick.jdbc.H2Profile.api._

class PostSummaryRepository {

  class PostSummaryTable(tag: Tag)
    extends Table[PostSummary](tag, &quot;post_summary&quot;) {

    def * = (postId, title) &lt;&gt; (PostSummary.tupled, PostSummary.unapply)
    def postId = column[String](&quot;post_id&quot;, O.PrimaryKey)
    def title = column[String](&quot;title&quot;)
  }

  val postSummaries = TableQuery[PostSummaryTable]

  def selectPostSummaries() = postSummaries.result
}
</code></pre><h2 id="Query-the-Read-Side-Database"><a class="section-marker" href="#Query-the-Read-Side-Database">§</a>Query the Read-Side Database</h2>
<p>Let us first look at how a service implementation can retrieve data from a relational database using Slick.</p>
<pre class="prettyprint"><code class="language-scala">import com.lightbend.lagom.scaladsl.api.{Service, ServiceCall}
import slick.jdbc.JdbcBackend.Database</code></pre>
<pre class="prettyprint"><code class="language-scala">class BlogServiceImpl(db: Database, val postSummaryRepo: PostSummaryRepository) extends BlogService {

  override def getPostSummaries() = ServiceCall { request =&gt;
    db.run(postSummaryRepo.selectPostSummaries())
  }</code></pre>
<p>Note that a Slick <a href="http://slick.lightbend.com/doc/3.2.1/api/#slick.jdbc.JdbcBackend$DatabaseDef">Database</a> is injected in the constructor together with the previously defined <code>PostSummaryRepository</code>. Slick&rsquo;s <a href="http://slick.lightbend.com/doc/3.2.1/api/#slick.jdbc.JdbcBackend$DatabaseDef">Database</a> allows the execution of the Slick <code>DBIOAciton</code> returned by <code>selectPostSummaries()</code>. Importantly, it also manages execution of the blocking JDBC calls in a thread pool designed to handle it, which is why it returns a <code>Future</code>.</p><h2 id="Update-the-Read-Side"><a class="section-marker" href="#Update-the-Read-Side">§</a>Update the Read-Side</h2>
<p>We need to transform the events generated by the <a href="PersistentEntity.html">Persistent Entities</a> into database tables that can be queried as illustrated in the previous section. For that we will implement a <a href="api/index.html#com/lightbend/lagom/scaladsl/persistence/ReadSideProcessor">ReadSideProcessor</a> with assistance from the <a href="api/index.html#com/lightbend/lagom/scaladsl/persistence/slick/SlickReadSide">SlickReadSide</a> support component. It will consume events produced by persistent entities and update one or more database tables that are optimized for queries.</p>
<p>This is how a <a href="api/index.html#com/lightbend/lagom/scaladsl/persistence/ReadSideProcessor">ReadSideProcessor</a> class looks like before filling in the implementation details:</p>
<pre class="prettyprint"><code class="language-scala">import akka.Done
import com.lightbend.lagom.scaladsl.persistence.AggregateEventTag
import com.lightbend.lagom.scaladsl.persistence.ReadSideProcessor
import com.lightbend.lagom.scaladsl.persistence.slick.SlickReadSide
import com.lightbend.lagom.scaladsl.persistence.EventStreamElement
import docs.home.scaladsl.persistence.SlickRepos.Full.PostSummaryRepository
import slick.dbio.DBIO

import scala.concurrent.ExecutionContext</code></pre>
<pre class="prettyprint"><code class="language-scala">class BlogEventProcessor(
  readSide: SlickReadSide,
  postSummaryRepo: PostSummaryRepository
) extends ReadSideProcessor[BlogEvent] {

  override def buildHandler(): ReadSideProcessor.ReadSideHandler[BlogEvent] = {
    // TODO build read side handler
    ???
  }

  override def aggregateTags: Set[AggregateEventTag[BlogEvent]] = {
    // TODO return the tag for the events
    ???
  }
}</code></pre>
<p>You can see that we have injected the Slick read-side support, this will be needed later.</p>
<p>You should already have implemented tagging for your events as described in the <a href="ReadSide.html">Read-Side documentation</a>, so first we&rsquo;ll implement the <code>aggregateTags</code> method in our read-side processor stub, like so:</p>
<pre class="prettyprint"><code class="language-scala">override def aggregateTags: Set[AggregateEventTag[BlogEvent]] =
  BlogEvent.Tag.allTags</code></pre><h3 id="Building-the-read-side-handler"><a class="section-marker" href="#Building-the-read-side-handler">§</a>Building the read-side handler</h3>
<p>The other method on the <code>ReadSideProcessor</code> is <code>buildHandler</code>. This is responsible for creating the <a href="api/index.html#com/lightbend/lagom/scaladsl/persistence/ReadSideProcessor.ReadSideHandler">ReadSideHandler</a> that will handle events. It also gives the opportunity to run two callbacks, one is a global prepare callback, the other is a regular prepare callback.</p>
<p><a href="api/index.html#com/lightbend/lagom/scaladsl/persistence/jdbc/SlickReadSide">SlickReadSide</a> has a <code>builder</code> method for creating a builder for these handlers, this builder will create a handler that will automatically manage transactions and handle read-side offsets for you. It can be created like so:</p>
<pre class="prettyprint"><code class="language-scala">val builder = readSide.builder[BlogEvent](&quot;blogsummaryoffset&quot;)</code></pre>
<p>The argument passed to this method is an identifier for the read-side processor that Lagom should use when it persists the offset. Lagom will store the offsets in a table that it will automatically create itself if it doesn&rsquo;t exist. If you would prefer that Lagom didn&rsquo;t automatically create this table for you, you can turn off this feature by setting <code>lagom.persistence.jdbc.create-tables.auto=false</code> in <code>application.conf</code>. The DDL for the schema for this table is as follows:</p>
<pre class="prettyprint"><code class="language-sql">CREATE TABLE read_side_offsets (
  read_side_id VARCHAR(255), tag VARCHAR(255),
  sequence_offset bigint, time_uuid_offset char(36),
  PRIMARY KEY (read_side_id, tag)
)
</code></pre><h3 id="Global-prepare"><a class="section-marker" href="#Global-prepare">§</a>Global prepare</h3>
<p>The global prepare callback runs at least once across the whole cluster. It is intended for doing things like creating tables and preparing any data that needs to be available before read side processing starts. Read side processors may be sharded across many nodes, and so tasks like creating tables should usually only be done from one node.</p>
<p>The global prepare callback is run from an Akka cluster singleton. It may be run multiple times - every time a new node becomes the new singleton, the callback will be run. Consequently, the task must be idempotent. If it fails, it will be run again using an exponential backoff, and the read side processing of the whole cluster will not start until it has run successfully.</p>
<p>Of course, setting a global prepare callback is completely optional, you may prefer to manage database tables manually, but it is very convenient for development and test environments to use this callback to create them for you.</p>
<p>Below is an example method that we&rsquo;ve implemented to create tables using Slick DDL generation. Note that at in its current state, Slick doesn&rsquo;t generate create table statements with &ldquo;IF NOT EXISTS&rdquo; clause. Therefore, we must do it programatically.</p>
<pre class="prettyprint"><code class="language-scala">import scala.concurrent.ExecutionContext.Implicits.global
import slick.jdbc.H2Profile.api._
import slick.jdbc.meta.MTable

class PostSummaryRepository {
  // table mapping omitted for conciseness
  val postSummaries = TableQuery[PostSummaryTable]

  def createTable = {
    MTable.getTables.flatMap { tables =&gt;
      if (!tables.exists(_.name.name == postSummaries.baseTableRow.tableName)) {
        postSummaries.schema.create
      } else {
        DBIO.successful(())
      }
    }.transactionally
  }
}</code></pre>
<p>The best place to define such a method is in your <code>Model Repository</code> where we usually add all code related to database operations.</p>
<p>It can then be registered as the global prepare callback in the <code>buildHandler</code> method:</p>
<pre class="prettyprint"><code class="language-scala">builder.setGlobalPrepare(postSummaryRepo.createTable)</code></pre><h3 id="Prepare"><a class="section-marker" href="#Prepare">§</a>Prepare</h3>
<p>In addition to the global prepare callback, there is also a prepare callback that can be specified by calling <a href="api/index.html#com.lightbend.lagom.scaladsl.persistence.slick.SlickReadSide$ReadSideHandlerBuilder@setPrepare">builder.setPrepare</a>. This will be executed once per shard, when the read side processor starts up.</p>
<p>If you read the <a href="ReadSideCassandra.html">Cassandra read-side support</a> guide, you may have seen this used to prepare database statements for later use. JDBC <code>PreparedStatement</code> instances, however, are not guaranteed to be thread-safe, so the prepare callback should not be used for this purpose with relational databases.</p>
<p>Again this callback is optional, and in our example we have no need for a prepare callback, so none is specified.</p><h3 id="Registering-your-read-side-processor"><a class="section-marker" href="#Registering-your-read-side-processor">§</a>Registering your read-side processor</h3>
<p>Once you&rsquo;ve created your read-side processor, you need to register it with Lagom. This is done using the <a href="api/index.html#com/lightbend/lagom/scaladsl/persistence/ReadSide"><code>ReadSide</code></a> component:</p>
<pre class="prettyprint"><code class="language-scala">class BlogServiceImpl(
  persistentEntityRegistry: PersistentEntityRegistry,
  readSide: ReadSide,
  myDatabase: MyDatabase) extends BlogService {

  readSide.register[BlogEvent](new BlogEventProcessor(myDatabase))</code></pre><h3 id="Event-handlers"><a class="section-marker" href="#Event-handlers">§</a>Event handlers</h3>
<p>The event handlers take an event and returns a Slick <code>DBIOAction</code>.</p>
<p>Here&rsquo;s an example callback for handling the <code>PostAdded</code> event:</p>
<pre class="prettyprint"><code class="language-scala">/* added to PostSummaryRepository to insert or update Post Summaries */
def save(postSummary: PostSummary) = {
  postSummaries.insertOrUpdate(postSummary).map(_ =&gt; Done)
}</code></pre>
<pre class="prettyprint"><code class="language-scala">private def processPostAdded(eventElement: EventStreamElement[PostAdded]): DBIO[Done] = {
  postSummaryRepo.save(
    PostSummary(
      eventElement.event.postId,
      eventElement.event.content.title
    )
  )
}</code></pre>
<p>This can then be registered with the builder using <code>setEventHandler</code>:</p>
<pre class="prettyprint"><code class="language-scala">builder.setEventHandler[PostAdded](processPostAdded)</code></pre>
<p>Once you have finished registering all your event handlers, you can invoke the <code>build</code> method and return the built handler:</p>
<pre class="prettyprint"><code class="language-scala">builder.build()</code></pre>